import json, os

from pydantic import ValidationError

from django.views import View
from django.views.decorators.csrf import csrf_exempt

from backend.views.http.responses.errors import MethodNotAllowed, UnsupportedMediaType, BadRequest
from backend.views.http.requests import PreparedRequest
from backend.conf.constants import (
    PERMITTED_HTTP_METHODS,
    PERMITTED_CONTENT_TYPES,
    LOCAL_DEV_HOSTS,
    TAPIS_DEV_URL
)
from backend.helpers.tapis import resolve_tenant_id
from backend.utils import one_in

class APIView(View):
    # All methods on the APIView do not require a CSRF token
    @csrf_exempt
    def dispatch(self, request, *args, **kwargs):
        if request.method not in PERMITTED_HTTP_METHODS:
            return MethodNotAllowed()

        # Set the request base url. If the request comes from a local source,
        # change the base_url to the dev url
        request.base_url = f"{request.scheme.replace('https', 'http')}s://{request.get_host()}"
        if one_in(LOCAL_DEV_HOSTS, request.base_url):
            request.base_url = TAPIS_DEV_URL

        # Set the request url
        request.url = request.base_url.rstrip("/") + "/" + request.path.lstrip("/")

        # Set the tenant_id of the request
        request.tenant_id = resolve_tenant_id(request.base_url)

        if request.method != "GET":
            # Accept only application/json for all non get methods
            if request.content_type not in PERMITTED_CONTENT_TYPES:
                return UnsupportedMediaType()

            # Ensure the body of the request is correctly encoded json
            try:
                self.request_body = json.loads(
                    b"{}" if request.body == b"" else request.body)
            except json.JSONDecodeError:
                return BadRequest(message=f"Could not decode request body: {request.body}")

        return super(APIView, self).dispatch(request, *args, **kwargs)

    # Takes a pydantic base model and tries to validate it.
    # If it fails, a BadRequest Response is returned with the error message
    # generated by pydantic
    def prepare(self, request_schema):
        try:
            request_object = request_schema(**self.request_body)
        except ValidationError as e:
            errors = [ f"{error['type']}. {error['msg']}: {error['loc']}" for error in json.loads(e.json())]
            failure_view = BadRequest(message="\n".join(errors))
            return PreparedRequest(is_valid=False, failure_view=failure_view)

        return PreparedRequest(body=request_object)